<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // Масив - це об'єкт, з цифровими іменами властивостей
        // Масив - це також об'єкт
        // змінна має  посилання на об'єкт
        // зва масиви будуть різні, так як вини мають різні посилання на ячейку в памя'ті, тому myArray != myArray2

        // КОЖЕН МАСИВ - ЦЕ ОБ'ЄКТ!!!

        // Варіант масиву створення 1
        const myArray = [1, 2, 3]
        console.log(myArray)
        // (3) [1, 2, 3]

        // Варіант масиву створення 2
        const myArray2 = new Array(1, 2, 3)
        console.log(myArray2)
        // (3) [1, 2, 3]

        // СТРУКТУРА МИСВА
        // Розгорнемо результат в консолі браузера
        // (3) [1, 2, 3]
        // 0: 1
        // 1: 2
        // 2: 3
        // length: 3
        // [[Prototype]]: Array(0)

        myArray2.length
        // 3

        // ОПЕРАТОР ДЛЯ ПОРІВНЯНН МАСИВІВ ТА ОБ'ЄКТІВ
        myArray === myArray2
        // false

        const myArray3 = myArray
        myArray === myArray3
        // true

        // МАСИВ ПРОТИ ОБ'ЄКТА
        const myObject = {
            0: 1,
            1: 2,
            2: 3,
            length: 3
        }
        // Відрізняється в джаному випадку прототип, тобто це впливає які методи стають доступні
        // Також в об'єкті не будуть автоматично оновлюваатися властивість length

        // РОБОТА З ЕЛЕМЕНТАМИ МАСИВА
        // Читаємо значення масису
        const myArray4 = [1, true, 'a']
        console.log(myArray4[0])
        console.log(myArray4[1])
        console.log(myArray4.length)

        // Точковий запис при цифровому записі не працює!!!
        // myArray4.0 - error
        // myArray4.'0' - error

        myArray4.length = 7 // Так робити не рекомендується
        // (7) [1, true, 'a', пусто × 4]

        // Порядок елементів в масиві важливий
        // Порядок починається з 0

        // Змінити значення певного елементу
        myArray4[1] = false

        // Додати новий елемент до масива
        // Для цього потріно знати довжину масиву
        // Тому краще викоритовувати спеціальні методи масиву
        myArray4[3] = true
        myArray4[4] = true

        // МЕТОДИ МАСИВА
        // Функцій вищого порядку в масивах, методами прототипів, функції прототипу
        // push - додати в кінець масиву
        // pop - видалити останній елемент масиву, а також повертає видалений елемент
        // shift - видалити перший елемент масива, також повертає виджалений елемент
        // unshift - додати елемент в початок масиву
        // forEach - арнумент являється функцією
        // map - очікує від нас колбек функцію, повертає новий масив
        // та інші
        // Їх можна визивати методом точкового запису

        // myArray4. - далі підказка

        // Розглянемо основні:
        // push - додати в кінець масиву
        myArray4.push('value push')
        // (6) [1, true, 'a', true, true, 'value push']

        // pop - видалити останній елемент масиву, а також повертає видалений елемент
        myArray4.pop()
        // (5) [1, true, 'a', true, true]
        const testPop = myArray4.pop()
        // (4) [1, true, 'a', true]
        console.log(testPop)
        // true

        // unshift - додати елемент в початок масиву
        // Зміниться індекс, індекс звувається
        myArray4.unshift(false)
        // (5) [false, 1, true, 'a', true]
        // false - тепер має індекс 0

        // shift - видалити перший елемент масива, також повертає виджалений елемент. Також він мутує об'єкт, навіть якщо призначено типром const, а масив це тип який маэ посилання, тому выдбуваэться мутацыя масива
        myArray4.shift()
        // false
        // (4) [1, true, 'a', true]

        // forEach - перебирає елементи масива
        // forEach - арнумент являється функцією
        // forEach, повертає undefined
        // використовуйте анонімні, стрілочні, колбек
        // Звісно, ми плануємо що в масиві значення це числа, в даному випадку, так як ми пножимо на 2
        myArray4.forEach(el => console.log(el * 2))
        // 2
        // VM144:1 NaN
        // VM144:1 2
        // undefined
        console.log(myArray4)
        // Як видно, ориганалд не змінився
        // (4) [1, true, 'a', true]

        // map - очікує від нас колбек функцію, повертає новий масив, аналогічно forEach тільки повертає новий масив
        const myArray5 = [1, 2, 3]
        console.log(myArray5) // (3) [1, 2, 3]

        // 1
        const newArray = myArray5.map(el => el * 3)
        console.log(newArray) // [3, 6, 9]
        console.log(myArray5) // [1, 2, 3]

        // 2
        const newArray2 = myArray5.map((el) => {
            el * 3
            // return el * 3
        })
        console.log(newArray2)
        // [undefined, undefined, undefined]
        // ха-ха, так як немає return, тому undefined

        // 3
        const newArray3 = myArray5.map(function (el) {
            // el * 3
            return el * 3
        })
        console.log(newArray3) // (3) [3, 6, 9]

    </script>
</body>
</html>